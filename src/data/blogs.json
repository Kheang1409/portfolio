[
  {
    "id": 1,
    "title": "KaiAssistant API: Building AI-Powered Portfolio with .NET 10 and Gemini",
    "description": "KaiAssistant â€” A production-ready ASP.NET Core Web API showcasing MCP compliance, RAG, and modern .NET architecture patterns.",
    "content": "\n# KaiAssistant API: Building AI-Powered Portfolio with .NET 10 and Gemini\n\nI recently completed **KaiAssistant**, a sophisticated backend API that demonstrates modern .NET architecture principles while providing AI-powered conversational capabilities for my professional portfolio. This project showcases how to build production-ready applications using clean architecture, MCP compliance, and retrieval-augmented generation (RAG).\n\n---\n\n## Project Overview\n\n**KaiAssistant** is a backend API designed to enhance portfolio websites with intelligent AI-powered interactions. Visitors can ask questions about my professional background, skills, and experience, and receive context-aware responses powered by Google Gemini and RAG technology.\n\nThe application demonstrates enterprise-grade software engineering practices:\n- **Model Context Protocol (MCP) Compliance** for AI model interactions\n- **Retrieval-Augmented Generation (RAG)** for accurate, context-aware responses\n- **Clean Architecture** with 4-layer separation of concerns\n- **CQRS Pattern** using MediatR for scalable command/query handling\n- **Production-Ready** resilience patterns, security, and monitoring\n\n---\n\n## Key Features\n\n### ðŸ¤– AI-Powered Assistant\n- **MCP-Compliant Gemini Integration**: Follows Model Context Protocol with camelCase configuration and proper payload structure\n- **Multi-Model Fallback**: Automatic failover from `gemini-2.0-flash` to `gemini-1.5-flash` for reliability\n- **Intelligent RAG Pipeline**: Semantic retrieval of resume chunks from MongoDB with keyword extraction and relevance ranking\n- **Context-Aware Responses**: System prompts with privacy controls and token optimization\n- **Production-Grade Resilience**:\n  - Exponential backoff retry policy (5 attempts, 250ms-3000ms + jitter)\n  - Circuit breaker pattern (opens after 5 failures for 30s)\n  - 30-second HTTP timeout\n\n### ðŸ“§ Contact Form Service\n- **Email Delivery**: SMTP-based message routing via MailKit\n- **Input Validation**: FluentValidation with comprehensive rules (max lengths, email format)\n- **Error Handling**: Graceful failure with user-friendly error messages\n\n### ðŸ¥ Health & Observability\n- **Health Endpoints**: `/api/health` for uptime monitoring\n- **Prometheus Metrics**: OpenTelemetry integration for production monitoring\n- **Structured Logging**: Comprehensive logging across all layers\n\n### ðŸ”’ Security\n- **Secret Management**: User secrets, environment variables, and Azure Key Vault support\n- **CORS Protection**: Configurable allowed origins for frontend integration\n- **Input Validation**: FluentValidation on all API requests\n- **Global Exception Handling**: Middleware prevents sensitive information leakage\n\n---\n\n## Architecture & Design Patterns\n\n### Clean Architecture (4 Layers)\n\nThe project follows clean architecture with clear separation of concerns:\n\n```\nAPI Layer (Controllers, Middleware)\n    â†“\nApplication Layer (Business Logic, Services, CQRS Handlers)\n    â†“\nDomain Layer (Entities, Interfaces)\n    â†“\nInfrastructure Layer (External Integrations)\n```\n\n### MCP Compliance\n\nAll Gemini API requests follow the Model Context Protocol with proper structure:\n- **Contents Array**: System messages + user messages in correct order\n- **CamelCase Configuration**: `generationConfig` with proper parameters\n- **Safety Settings**: Compliance with Gemini safety guidelines\n- **Model Format**: `{model}:{action}` pattern for multi-model support\n\n### RAG (Retrieval-Augmented Generation)\n\nThe RAG pipeline provides accurate, context-aware responses:\n1. **Keyword Extraction**: Analyze user question for relevant terms\n2. **Chunk Retrieval**: Query MongoDB for resume sections matching keywords\n3. **Relevance Ranking**: Score chunks by relevance (0-10 scale)\n4. **Context Limiting**: Keep top 8 chunks within token limits\n5. **Prompt Building**: Construct MCP-compliant request with system prompt + context\n6. **AI Generation**: Send to Gemini with automatic fallback\n7. **Response Parsing**: Extract clean text from AI response\n\n### CQRS Pattern (MediatR)\n\nCommands and queries are clearly separated:\n- **Commands**: `AskAssistantCommand` for asking questions (write operation)\n- **Queries**: Future-proof architecture for read-only operations\n- **Handlers**: Decoupled, testable business logic with cancellation token support\n- **Validation**: Pipeline behavior validates requests before handling\n\n---\n\n## Technology Stack\n\n### Core Framework\n- **.NET 10.0** - Latest .NET framework with enhanced performance\n- **ASP.NET Core** - RESTful Web API framework\n- **C# 13** - Modern language features\n\n### AI & Data\n- **Google Gemini API** (v1beta) - AI language model with 2 flash variants\n- **MongoDB 3.0.0** - Document database for resume storage\n- **RAG Pattern** - Context augmentation for AI responses\n\n### Architecture & Patterns\n- **MediatR 12.5.0** - CQRS implementation\n- **FluentValidation 11.11.0** - Request validation\n- **Polly 8.2.0** - Resilience patterns (retry, circuit breaker)\n- **MailKit 4.12.1** - SMTP email delivery\n\n### Observability\n- **OpenTelemetry** - Distributed tracing\n- **Prometheus** - Metrics collection\n- **Structured Logging** - Comprehensive application insights\n\n### Testing & Quality\n- **xUnit 2.6.2** - Test framework\n- **FluentAssertions 6.9.0** - Fluent test assertions\n- **Moq 4.18.4** - Mocking framework\n- **Mongo2Go 4.0.0** - In-memory MongoDB for testing\n- **Test Coverage**: 17 tests, 100% passing\n\n### DevOps\n- **Docker** - Multi-stage builds for optimized images\n- **GitHub** - Version control and CI/CD\n\n---\n\n## Implementation Highlights\n\n### Cancellation Token Propagation\n\nFixed critical async issue by properly propagating cancellation tokens through the call chain:\n\n```csharp\n// BEFORE: Missing cancellation token\nawait _service.AskQuestionAsync(command.Question);\n\n// AFTER: Proper propagation\nawait _service.AskQuestionAsync(command.Question, cancellationToken);\n```\n\nThis ensures:\n- Graceful shutdown support\n- Request timeout handling\n- Resource cleanup on cancellation\n\n### MCP Payload Construction\n\nImplemented strict MCP compliance with proper structure:\n\n```json\n{\n  \"contents\": [\n    {\"role\": \"user\", \"parts\": [{\"text\": \"System prompt with context\"}]},\n    {\"role\": \"user\", \"parts\": [{\"text\": \"User question\"}]}\n  ],\n  \"generationConfig\": {\n    \"temperature\": 0.4,\n    \"topK\": 20,\n    \"topP\": 0.85,\n    \"maxOutputTokens\": 768,\n    \"candidateCount\": 1\n  },\n  \"safetySettings\": [...]\n}\n```\n\n### Resilience Patterns\n\nImplemented production-grade reliability:\n\n```csharp\n// Retry Policy: 5 attempts with exponential backoff\nretryPolicy = HttpPolicyExtensions\n    .HandleTransientHttpError()\n    .OrResult(r => r.StatusCode == System.Net.HttpStatusCode.TooManyRequests)\n    .WaitAndRetryAsync(\n        retryCount: 5,\n        sleepDurationProvider: attempt => \n            TimeSpan.FromMilliseconds(Math.Pow(2, attempt) * 250) + \n            TimeSpan.FromMilliseconds(jitter.Next(0, 100))\n    );\n\n// Circuit Breaker: Open after 5 failures for 30 seconds\ncircuitBreakerPolicy = HttpPolicyExtensions\n    .HandleTransientHttpError()\n    .CircuitBreakerAsync(handledEventsAllowedBeforeBreaking: 5,\n        durationOfBreak: TimeSpan.FromSeconds(30));\n```\n\n---\n\n## Key Learnings & Improvements\n\n### MCP Compliance Score: 95/100 â†’ 98/100\n\nImplemented 5 priority recommendations:\n\n1. **HIGH: Cancellation Token Propagation**\n   - Fixed async chain to properly propagate cancellation tokens\n   - Enables graceful shutdown and timeout handling\n\n2. **HIGH: Security Documentation**\n   - Created `SECURITY_SETUP.md` with comprehensive API key management guide\n   - Covers user secrets, environment variables, and Azure Key Vault\n\n3. **MEDIUM: Removed Duplicate Registration**\n   - Cleaned up duplicate `IAssistantService` registration\n   - Maintained single registration in infrastructure layer\n\n4. **MEDIUM: Removed Unused Packages**\n   - Eliminated OllamaSharp and OpenAI dependencies\n   - Reduced build size and dependency footprint\n\n5. **LOW: Documented Model Name Convention**\n   - Documented `{model}:{action}` format in MCP guide\n   - Explained multi-model fallback strategy\n\n### Test Suite: 16/17 â†’ 17/17 Passing âœ…\n\n- Fixed typo: `\"RecieverEmail\"` â†’ `\"ReceiverEmail\"` in test configuration\n- All 17 unit tests passing with 100% success rate\n- Comprehensive coverage of RAG, MCP compliance, and error handling\n\n### Code Quality Improvements\n\n- Removed obsolete tests for deleted methods\n- Improved error messages for better debugging\n- Added comprehensive documentation\n- Reduced dependency complexity\n\n---\n\n## What This Project Taught Me\n\n### 1. **AI Integration Best Practices**\n- Implementing MCP compliance for standardized AI model interactions\n- Building RAG pipelines for context-aware AI responses\n- Handling multi-model fallback for reliability\n- Managing token limits and prompt optimization\n\n### 2. **Production-Grade Architecture**\n- Clean Architecture with proper separation of concerns\n- CQRS pattern for scalable command/query handling\n- Resilience patterns (retry, circuit breaker) for fault tolerance\n- Comprehensive exception handling and logging\n\n### 3. **Async/Await Best Practices**\n- Proper cancellation token propagation through call chains\n- Avoiding common async gotchas\n- Ensuring graceful shutdown support\n\n### 4. **Security & Secret Management**\n- User secrets for development\n- Environment variables for production\n- Azure Key Vault integration\n- Never committing secrets to source control\n\n### 5. **Testing & Quality**\n- Unit testing with xUnit and Moq\n- In-memory database testing with Mongo2Go\n- Comprehensive test coverage\n- Test-driven design patterns\n\n### 6. **Observability & Monitoring**\n- OpenTelemetry for distributed tracing\n- Prometheus metrics for monitoring\n- Structured logging for debugging\n- Health check endpoints\n\n### 7. **MCP & Protocol Compliance**\n- Understanding Model Context Protocol specifications\n- Implementing camelCase configuration\n- Proper contents array ordering\n- Safety settings compliance\n\n### 8. **DevOps & Containerization**\n- Multi-stage Docker builds for optimization\n- Environment-specific configurations\n- Azure deployment strategies\n- CI/CD pipeline integration\n\n---\n\n## Future Enhancements\n\n### Planned Features\n\n1. **Vector Search**: Implement semantic search using embeddings for more accurate RAG\n2. **Response Caching**: Add Redis caching for frequently asked questions\n3. **WebSocket Support**: Real-time chat capabilities for interactive conversations\n4. **Multi-Language**: Support responses in different languages\n5. **Authentication**: JWT-based API authentication for controlled access\n6. **Rate Limiting**: Per-user rate limiting to prevent abuse\n7. **Analytics**: Track user interactions and conversation patterns\n8. **Model A/B Testing**: Compare performance of different AI models\n\n### Technical Debt\n\n- Explore async stream support for large dataset handling\n- Consider database indexing optimization for RAG retrieval\n- Implement comprehensive API documentation with OpenAPI/Swagger\n- Add performance benchmarking suite\n\n---\n\n## Project Stats\n\n- **Build Time**: 1.5 seconds (clean build)\n- **Test Coverage**: 17/17 tests passing (100%)\n- **Lines of Code**: 4,000+ across 4 projects\n- **Documentation**: 900+ lines (README, MCP guide, security guide)\n- **Dependencies**: 15+ production packages\n- **Architecture Score**: 98/100 (MCP compliance)\n\n---\n\n## Deployment\n\nThe project is deployment-ready with multiple options:\n\n- **Docker**: Multi-stage builds for optimized container images\n- **Azure App Service**: Direct deployment from GitHub\n- **Azure Container Apps**: Containerized deployment with managed infrastructure\n- **AKS**: Kubernetes deployment for enterprise scalability\n\n---\n\n## Conclusion\n\nKaiAssistant demonstrates how to build production-ready AI-powered applications using modern .NET practices. It combines sophisticated architecture patterns (Clean Architecture, CQRS, RAG) with enterprise-grade reliability features (resilience patterns, security, observability).\n\nThis project reinforced important lessons about:\n- Building scalable, maintainable systems\n- Implementing AI integrations correctly (MCP compliance)\n- Creating resilient distributed systems\n- Writing comprehensive, clear documentation\n- Balancing technical excellence with practical business value\n\nThe codebase serves as a practical example for other developers looking to implement similar patterns and demonstrates my ability to design and implement complex, production-grade applications.\n\n---\n\n**Want to explore the code?** Check out the [GitHub repository](https://github.com/Kheang1409/ContactFormApi) and the comprehensive documentation in the project root.\n\n",
    "slug": "kaiassistant-api-ai-portfolio",
    "link": "/blog/kaiassistant-api-ai-portfolio",
    "date": "2025-12-05",
    "tags": [
      ".NET",
      "AI",
      "Gemini",
      "RAG",
      "Architecture",
      "Production",
      "MCP"
    ],
    "image": null
  },
  {
    "id": 2,
    "title": "Portfolio Overview",
    "description": "Overview of the portfolio repository structure, backend/frontend, and the blog system.",
    "content": "\r\nThis post summarizes the structure and setup of my portfolio repository, including the backend API (`KaiAssistant`), the original Angular frontend, and the new Next.js frontend. It includes notes on architecture, migration, and how the blog system is implemented.\r\n\r\n## Project Overview\r\n\r\n### Backend: KaiAssistant\r\n\r\nThe backend is an ASP.NET Core Web API structured with Domain-Driven Design (DDD). The projects are organized as follows:\r\n\r\n- `KaiAssistant.Domain` â€” domain entities and models\r\n- `KaiAssistant.Application` â€” commands, queries, and handlers\r\n- `KaiAssistant.Infrastructure` â€” persistence, DI, and external integrations\r\n- `KaiAssistant.API` â€” HTTP endpoints, middleware, and assistant endpoints\r\n\r\n### Frontend Migration: Angular â†’ Next.js\r\n\r\nThe original frontend was Angular-based. I migrated to a `frontent` Next.js + TypeScript project for:\r\n\r\n- Component-first architecture and faster iteration\r\n- Simplified tooling and reduced bundle size\r\n- Improved SSR/SSG support for blog posts\r\n\r\nKey migration points:\r\n\r\n- Routes were mapped from Angular to Next.js pages; dynamic routes like `/blog/[slug]` use static generation.\r\n- Global styles moved to `src/styles`; components use CSS Modules.\r\n- Local markdown posts are read at build time. `blogs.json` now indexes both internal and external posts.\r\n- Carousel and scroll interactions were reimplemented with scroll-snap and pointer events.\r\n\r\n### Frontend (Next.js)\r\n\r\nThe current frontend is component-based, DRY, and uses the blog system reading markdown posts from `src/data/blogs/*.md` combined with `blogs.json` for external entries.\r\n\r\n## Key Features\r\n\r\n- **KaiAssistant API**\r\n\r\n  - Modular DDD structure\r\n  - Health, assistant, and contact endpoints\r\n  - Gemini API integration (requires `GEMINI_API_KEY`)\r\n  - SMTP email support\r\n  - Docker-ready with `docker-compose`\r\n\r\n- **Frontend**\r\n  - Blog index merging local markdown and external posts\r\n  - BlogItem component with CSS Modules\r\n  - Dynamic pages `/blog/[slug]` built statically at compile time\r\n\r\n## Running the Project\r\n\r\n### Backend (KaiAssistant)\r\n\r\nRequirements: .NET 9 SDK, Gemini API key (optional), SMTP credentials (if sending email).\r\n\r\n```bash\r\ncd backend\r\ndotnet restore\r\ndotnet build\r\ndotnet run --project KaiAssistant.API\r\n```\r\n\r\nDocker option:\r\n\r\n```bash\r\ndocker build -t kaiassistant-api .\r\ndocker run -p 5000:5000 \\\r\n  -e GEMINI_API_KEY=your-key \\\r\n  -e SMTP_SENDER_EMAIL=... \\\r\n  kaiassistant-api\r\n```\r\n\r\n### Frontend (Next.js)\r\n\r\n```bash\r\ncd frontend\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\nFor production:\r\n\r\n```bash\r\nnpm run build\r\nnpm start\r\n```\r\n\r\nSite: `http://localhost:3000`.\r\n\r\n## Blog System Notes\r\n\r\n- Local markdown posts in `src/data/blogs/*.md` use frontmatter (title, date, slug).\r\n- `blogs.json` indexes external/internal posts. Local posts override external if slugs match.\r\n- BlogItem links open in a new tab by default.\r\n\r\n## Suggested Improvements\r\n\r\n- Add pagination and date sorting on `/blog`\r\n- Include SEO meta tags and Open Graph data on posts\r\n- Add author profile and tags for better navigation\r\n- Expand tests for blog pages\r\n- Add retry/backoff for Gemini API calls and rate limit handling\r\n\r\n## Summary\r\n\r\nThe repository combines a DDD-based backend with a lean Next.js frontend. Blog posts are easy to add: create a markdown file with frontmatter and rebuild. The setup supports scalable development and clear project organization.\r\n",
    "slug": "portfolio-overview",
    "link": "/blog/portfolio-overview",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": ["portfolio", "kaiassistant", "nextjs", "dotnet", "architecture"],
    "image": null
  },
  {
    "id": 3,
    "title": "BiUrSite: A Web Application for Sharing Ideas and Seeking Advice",
    "description": "BiUrSite â€” a web app for sharing ideas, with anonymous browsing and verified user interaction.",
    "content": "\r\nIn today's digital world, having a safe and engaging space to share ideas, thoughts, and challenges is more important than ever. **BiUrSite** is a web application I developed to allow users to express themselves, post anonymously or through verified accounts, and receive advice from a supportive community.\r\n\r\n---\r\n\r\n## Core Features\r\n\r\n### Anonymous Users\r\n\r\n- Can browse all posts without registering.\r\n- Limited to viewing onlyâ€”no interaction allowed.\r\n\r\n### Verified Users\r\n\r\n- Can upload posts and comment on existing posts.\r\n- Report issues, provide feedback, and suggest improvements.\r\n- Must verify email to ensure authenticity.\r\n\r\n### Admin Dashboard\r\n\r\n- View total posts, active users, and reports.\r\n- Ban users based on behavior.\r\n- Publish announcements visible to all users.\r\n\r\n### Additional Features\r\n\r\n- **Email Verification:** Ensures that users are real and active.\r\n- **Ratings & Feedback:** Users can rate posts and provide feedback on advice given.\r\n\r\n---\r\n\r\n## Technical Stack\r\n\r\n**Backend**\r\n\r\n- .NET API (latest version)\r\n- MSSQL Database\r\n- Redis Distributed Cache for performance optimization\r\n- SMTP Email Service\r\n- xUnit for unit testing\r\n- Role-based & policy-based authentication and authorization\r\n\r\n**Frontend**\r\n\r\n- Angular framework\r\n- Initial data via `data.json`\r\n- Admin portal built with Razor pages and API\r\n\r\n**Deployment & DevOps**\r\n\r\n- Docker containerization for backend, frontend, and SQL Server\r\n- Kubernetes orchestration for cloud deployment\r\n- AWS / Azure for production hosting\r\n- Configuration management via `appsettings.json` (backend) and `environment.variable.ts` (frontend)\r\n\r\n---\r\n\r\n## Project Phases\r\n\r\n### Phase 1: Initial Setup\r\n\r\n- Design project structure\r\n- Build working API with OpenAPI documentation\r\n- Version the API for future changes\r\n- Implement basic CRUD operations\r\n- Write unit tests for each module\r\n\r\n### Phase 2: Authentication & Authorization\r\n\r\n- Implement AuthN and AuthZ\r\n- Update unit tests to reflect new authentication logic\r\n\r\n### Phase 3: Security Enhancements\r\n\r\n- Fix potential vulnerabilities: DDOS, XSS, CSRF attacks\r\n\r\n### Phase 4: Frontend Implementation\r\n\r\n- Build frontend pages using static `data.json`\r\n- Implement user interface for posts, comments, and feedback\r\n\r\n### Phase 5: Integration\r\n\r\n- Connect backend API with frontend\r\n- Test API calls and dynamic data handling\r\n\r\n### Phase 6: Deployment\r\n\r\n- Containerize services using Docker\r\n- Deploy using Kubernetes on AWS/Azure\r\n\r\n---\r\n\r\n## Docker Setup\r\n\r\n**Services:**\r\n\r\n- `sql_server_container`: SQL Server container storing application data\r\n- `backend`: .NET API backend\r\n- `frontend`: Angular frontend communicating with backend\r\n\r\n**Run the Application:**\r\n\r\n```bash\r\ndocker-compose up --build\r\n```\r\n",
    "slug": "biursite-project",
    "link": "/blog/biursite-project",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": [
      "Web Development",
      "Full-Stack",
      "Next.js",
      "Angular",
      ".NET",
      "Docker",
      "AWS"
    ],
    "image": null
  },
  {
    "id": 4,
    "title": "The C#/.NET Revolution: Improvements Across Versions",
    "description": "A concise overview of major C# and .NET improvements across versions.",
    "content": "\r\nC# and the .NET ecosystem have evolved tremendously since their inception. Each version of the language and framework has brought new features, performance improvements, and productivity boosts for developers. Hereâ€™s a chronological look **from the latest version down to the earliest**, highlighting the most significant changes.\r\n\r\n---\r\n\r\n## C#â€¯13 and .NETâ€¯9\r\n\r\n- **Released:** November 2024\r\n- **Key Features:**\r\n  - `params` collections for more flexible argument handling.\r\n  - New `System.Threading.Lock` type for improved thread synchronization.\r\n  - Implicit â€œfrom the endâ€ (`^`) index operator in object initializers.\r\n  - Ref/unsafe support in iterators/async methods, partial properties/indexers.\r\n- **.NETâ€¯9 Enhancements:**\r\n  - Runtime improvements: adaptive GC heap, ARM64 vectorization, faster startup.\r\n  - Library enhancements: `System.Text.Json` schema export, LINQ `CountBy`/`AggregateBy`, improved priority queues.\r\n  - Cloud/AI tooling: unified AI layer, tensor support, improved SDK tooling.\r\n- **Impact:** High-performance, cloud-native readiness, and AI/ML support; STS (short-term support) release.\r\n\r\n---\r\n\r\n## C#â€¯12 and .NETâ€¯8\r\n\r\n- **Expected:** 2025\r\n- **Key Features:**\r\n  - Primary constructors for structs.\r\n  - Default lambda expressions for delegates.\r\n  - Collection expressions and improved interpolated strings.\r\n- **Impact:** Further reduces boilerplate, improves readability, and boosts performance.\r\n\r\n---\r\n\r\n## C#â€¯11 and .NETâ€¯7\r\n\r\n- **Released:** 2022\r\n- **Key Features:**\r\n  - Raw string literals.\r\n  - List patterns.\r\n  - Required members.\r\n  - Generic math support, UTF-8 string literals.\r\n- **Impact:** Simplifies multi-line strings, strengthens pattern matching, enhances generic math support.\r\n\r\n---\r\n\r\n## C#â€¯10 and .NETâ€¯6\r\n\r\n- **Released:** 2021\r\n- **Key Features:**\r\n  - Global using directives.\r\n  - File-scoped namespaces.\r\n  - Record structs.\r\n  - Improved pattern matching, interpolated string handlers.\r\n- **Impact:** Reduced boilerplate, improved compile-time safety, long-term support (LTS).\r\n\r\n---\r\n\r\n## C#â€¯9 and .NETâ€¯5\r\n\r\n- **Released:** 2020\r\n- **Key Features:**\r\n  - Records and init-only setters.\r\n  - Top-level statements.\r\n  - Pattern matching enhancements, covariant returns.\r\n- **Impact:** Simplifies immutable data modeling and small programs; unified .NET platform.\r\n\r\n---\r\n\r\n## C#â€¯8 and .NET Coreâ€¯3\r\n\r\n- **Released:** 2019\r\n- **Key Features:**\r\n  - Nullable reference types.\r\n  - Asynchronous streams.\r\n  - Ranges and indices, default interface methods.\r\n- **Impact:** Improves safety, simplifies large data streaming, and allows better API evolution.\r\n\r\n---\r\n\r\n## C#â€¯7.x and .NET Coreâ€¯1+\r\n\r\n- **Released:** 2016â€“2017\r\n- **Key Features:**\r\n  - Tuples, pattern matching.\r\n  - Local functions, out variables, ref returns.\r\n- **Impact:** More expressive code and cross-platform capabilities with .NET Core.\r\n\r\n---\r\n\r\n## C#â€¯6 and .NET Frameworkâ€¯4.6\r\n\r\n- **Released:** 2015\r\n- **Key Features:**\r\n  - Expression-bodied members.\r\n  - String interpolation.\r\n  - Null-conditional operators (`?.`), `nameof`.\r\n- **Impact:** Cleaner, safer, more readable code.\r\n\r\n---\r\n\r\n## C#â€¯5 and .NET Frameworkâ€¯4.5\r\n\r\n- **Released:** 2012\r\n- **Key Features:**\r\n  - Async and await keywords.\r\n  - Caller Info attributes.\r\n- **Impact:** Simplifies asynchronous programming, improving maintainability and I/O performance.\r\n\r\n---\r\n\r\n## C#â€¯4 and .NET Frameworkâ€¯4.0\r\n\r\n- **Released:** 2010\r\n- **Key Features:**\r\n  - Dynamic binding (`dynamic`).\r\n  - Optional parameters, named arguments.\r\n  - Improved COM interoperability.\r\n- **Impact:** Simplifies interop with dynamic languages and COM objects; cleaner APIs.\r\n\r\n---\r\n\r\n## C#â€¯3 and .NET Frameworkâ€¯3.5\r\n\r\n- **Released:** 2007\r\n- **Key Features:**\r\n  - LINQ, lambda expressions.\r\n  - Extension methods, object and collection initializers.\r\n- **Impact:** Revolutionized querying and in-memory data manipulation; functional programming style support.\r\n\r\n---\r\n\r\n## C#â€¯2 and .NET Frameworkâ€¯2.0\r\n\r\n- **Released:** 2005\r\n- **Key Features:**\r\n  - Generics, nullable types.\r\n  - Iterators (`yield`), partial classes, anonymous methods.\r\n- **Impact:** Type-safe collections, simplified iteration, and database value handling.\r\n\r\n---\r\n\r\n## C#â€¯1 and .NET Frameworkâ€¯1.0\r\n\r\n- **Released:** 2002\r\n- **Key Features:**\r\n  - Classes, interfaces, delegates, properties, exception handling.\r\n- **Impact:** Laid the foundation for object-oriented programming in C# and introduced the managed runtime.\r\n\r\n---\r\n\r\n## The Big Picture\r\n\r\nFrom its beginnings in 2002 to the latest C#â€¯13/.NETâ€¯9 release, C# and .NET have evolved into a high-performance, cross-platform ecosystem. Microsoft has consistently focused on:\r\n\r\n- **Performance:** Runtime and JIT improvements.\r\n- **Productivity:** Reduced boilerplate, modern syntax.\r\n- **Safety:** Null safety, type safety, immutability.\r\n- **Cross-platform:** From Windows-only to Linux, macOS, and mobile apps.\r\n\r\nC# and .NET remain powerful tools for modern software development, proving that thoughtful evolution can keep a language and framework relevant for decades.\r\n\r\n---\r\n\r\n> _â€œC# has evolved from a simple object-oriented language into a versatile platform for building modern, high-performance applications. Every version brings both incremental and groundbreaking improvements, shaping how developers write software today.â€_\r\n",
    "slug": "csharp-dotnet-evolution",
    "link": "/blog/csharp-dotnet-evolution",
    "date": "2025-11-11",
    "tags": [],
    "image": null
  },
  {
    "id": 5,
    "title": "Job Tracker Web Application: A Modern .NET Microservices Project",
    "description": "Job Tracker â€” a .NET microservices example demonstrating DDD and CQRS.",
    "content": "\r\nThe **Job Tracker Web Application** is designed to help users manage job listings, applications, and status updates. This project was developed solo to explore microservices, Domain-Driven Design (DDD), CQRS (Command Query Responsibility Segregation), and the full software development lifecycle. It leverages modern .NET best practices for scalability, clean code, and maintainability.\r\n\r\n---\r\n\r\n## Key Features\r\n\r\n- **Job Listings Management:** Create, read, update, and delete job postings.\r\n- **Job Applications:** Users can apply for jobs and track their application status.\r\n- **CQRS:** Commands (write operations) and queries (read operations) are clearly separated for improved scalability.\r\n- **Email Notifications:** Automated emails notify users when job statuses change.\r\n- **Microservices Architecture:** The application is modularized into microservices to enhance maintainability and scalability.\r\n- **Clean Code & DDD:** Implements Domain-Driven Design principles for a maintainable and scalable architecture.\r\n\r\n---\r\n\r\n## Tech Stack\r\n\r\n- **Backend:** .NET 6+ (C#)\r\n- **Architecture:** Microservices, CQRS, Domain-Driven Design\r\n- **Frameworks & Tools:**\r\n  - MediatR: CQRS command and query handling\r\n  - SendGrid / SMTP: Email notifications\r\n  - Serilog: Structured logging\r\n  - Moq / NUnit: Unit testing\r\n  - Docker (optional): Containerization\r\n  - CI/CD: GitHub Actions or GitLab CI pipelines\r\n  - EF Core: Database ORM\r\n\r\n---\r\n\r\n## Setup\r\n\r\n### Prerequisites\r\n\r\nBefore running the application, ensure you have:\r\n\r\n- **.NET 6+ SDK** installed ([Download .NET](https://dotnet.microsoft.com/download))\r\n- **Docker** (optional, for containerization)\r\n- **SMTP/SendGrid account** for email notifications\r\n\r\n---\r\n\r\n### Installation Steps\r\n\r\n1. **Clone the Repository**\r\n\r\n```bash\r\ngit clone git@github.com:Kheang1409/job-tracker-api.git\r\ncd job-tracker-api\r\n```\r\n\r\n2. **Install Dependencies**\r\n\r\n```bash\r\ndotnet restore\r\n```\r\n\r\n3. **Configure Environment Variables**\r\n\r\n- Set up `.env` or `appsettings.json` with email credentials and database connection strings.\r\n\r\n4. **Run the Application**\r\n\r\n```bash\r\ndotnet run --project JobTracker.Api\r\n```\r\n\r\n5. **Optional: Run with Docker**\r\n\r\n```bash\r\ndocker-compose up --build\r\n```\r\n\r\n---\r\n\r\n## What I Learned\r\n\r\nBuilding this project taught me a wide range of technical and architectural skills:\r\n\r\n- **Domain-Driven Design (DDD):** Learned how to model complex business domains using aggregates, entities, and value objects.\r\n- **CQRS Implementation:** Understood the benefits of separating write operations (commands) from read operations (queries) to improve scalability and maintainability.\r\n- **Microservices Architecture:** Gained practical experience decomposing a monolithic application into loosely coupled services.\r\n- **Asynchronous Email Handling:** Integrated SendGrid/SMTP for real-time email notifications using background services.\r\n- **Unit Testing & Mocks:** Learned to write effective tests for CQRS commands, queries, and services using Moq and NUnit.\r\n- **Logging & Observability:** Implemented structured logging with Serilog for better monitoring and debugging.\r\n- **Containerization & CI/CD:** Practiced containerizing the services with Docker and setting up continuous integration pipelines with GitHub Actions or GitLab CI.\r\n- **Clean Code & Maintainability:** Applied SOLID principles and DDD to produce modular, maintainable, and testable code.\r\n\r\n---\r\n\r\nThis project demonstrates modern .NET architecture principles while providing a functional job tracking platform. It serves as a practical example of scalable, maintainable, and testable enterprise-grade application design.\r\n\r\n---\r\n\r\nIf you want, I can **also add a â€œNext Steps / Future Enhancementsâ€ section linked to the lessons learned**, so it not only shows what you learned but also what you plan to do next, making it more engaging for readers and potential employers. Do you want me to do that?\r\n\r\n```\r\n\r\n```\r\n",
    "slug": "job-tracker-web-application",
    "link": "/blog/job-tracker-web-application",
    "date": "2025-11-11",
    "tags": [],
    "image": null
  },
  {
    "id": 6,
    "title": "DDD: Rich Domain Model vs Anemic Domain Model",
    "description": "Brief comparison of Rich and Anemic domain models, with guidance for choosing between them.",
    "content": "\r\n> Short summary: Rich domain models encapsulate behavior and data together (the object is responsible for its invariants). Anemic models keep data and behavior separate (DTOs/entities are data-only). Each approach has trade-offs â€” this post explains both, shows examples, and gives guidance for choosing or migrating.\r\n\r\n## What is an Anemic Domain Model?\r\n\r\nAn Anemic Domain Model keeps entities as data containers (properties only). Business logic and rules live in separate services or application layers. This can be simple and straightforward, but risks scattering rules across services and losing encapsulation.\r\n\r\nPros:\r\n\r\n- Simple DTO-like entities\r\n- Easy to serialize/deserialize and map to persistence\r\n- Familiar to teams coming from CRUD/service-oriented patterns\r\n\r\nCons:\r\n\r\n- Business rules are often duplicated or scattered\r\n- Harder to guarantee object invariants\r\n- Tests can become larger (need to set up data and call services)\r\n\r\nExample (C# - anemic):\r\n\r\n```csharp\r\npublic class Order {\r\n  public Guid Id { get; set; }\r\n  public List<OrderLine> Lines { get; set; }\r\n  public decimal Total { get; set; }\r\n}\r\n\r\npublic class OrderService {\r\n  public void AddItem(Order order, Product p, int qty) {\r\n    // service mutates Order and updates Total\r\n  }\r\n}\r\n```\r\n\r\n## What is a Rich (Behaviorful) Domain Model?\r\n\r\nA Rich Domain Model puts behavior inside the domain objects. Entities enforce their own invariants and provide meaningful methods to operate on them. This matches the core DDD idea: the domain model expresses the domain language and protects its invariants.\r\n\r\nPros:\r\n\r\n- Encapsulation: invariants are enforced in one place\r\n- Clear, intention-revealing APIs (Order.AddItem())\r\n- Easier to reason about correctness and test behavior directly\r\n\r\nCons:\r\n\r\n- Slightly more design effort initially\r\n- Need clear boundaries to avoid anemic services hiding inside objects\r\n\r\nExample (C# - rich):\r\n\r\n```csharp\r\npublic class Order {\r\n  private readonly List<OrderLine> _lines = new();\r\n  public IReadOnlyCollection<OrderLine> Lines => _lines.AsReadOnly();\r\n\r\n  public void AddItem(Product p, int qty) {\r\n    if (qty <= 0) throw new ArgumentException(\"qty\");\r\n    var existing = _lines.FirstOrDefault(l => l.ProductId == p.Id);\r\n    if (existing != null) existing.Increase(qty);\r\n    else _lines.Add(new OrderLine(p.Id, p.Price, qty));\r\n  }\r\n\r\n  public decimal Total => _lines.Sum(l => l.Subtotal);\r\n}\r\n```\r\n\r\nHere `Order` manages its lines and computes the total â€” callers can't put the `Order` into an invalid state without calling its API.\r\n\r\n## Choosing between them\r\n\r\n- Start with the domain complexity: If your domain has non-trivial rules and invariants, prefer a rich model.\r\n- If your application is primarily CRUD with thin business logic, an anemic model with services can be pragmatic.\r\n- Teams moving to DDD often start with anemic models and gradually introduce rich behaviors where it matters.\r\n\r\n## Migration tips (Anemic â†’ Rich)\r\n\r\n1. Identify invariants & business rules currently enforced in services or spread across code.\r\n2. Introduce small, focused domain methods that encapsulate those rules (e.g., `Order.AddItem`, `Customer.CanPlaceOrder`).\r\n3. Keep persistence mapping straightforward: repositories still persist entities, but call domain methods instead of manipulating properties directly.\r\n4. Add tests around domain behaviors (unit tests on the domain object) before removing service-level logic.\r\n\r\n## Small JS/TS example (Rich model flavor)\r\n\r\n```ts\r\nclass Order {\r\n  private lines: OrderLine[] = [];\r\n\r\n  addItem(product: Product, qty: number) {\r\n    if (qty <= 0) throw new Error(\"qty must be > 0\");\r\n    const item = this.lines.find((l) => l.productId === product.id);\r\n    if (item) item.qty += qty;\r\n    else this.lines.push({ productId: product.id, price: product.price, qty });\r\n  }\r\n\r\n  total() {\r\n    return this.lines.reduce((s, l) => s + l.price * l.qty, 0);\r\n  }\r\n}\r\n```\r\n\r\n## When to avoid a rich model\r\n\r\n- Extremely simple CRUD apps where all business logic is in stored procedures or in a gateway layer.\r\n- When team familiarity and delivery speed require minimal upfront design â€” but add targeted rich models where bugs or duplication appear.\r\n\r\n## Summary\r\n\r\nBoth patterns are valid. Prefer a rich, behaviorful domain model when domain rules, invariants, and maintainability matter. Use anemic models pragmatically for simple data-centric applications, but remain ready to extract domain behaviors into objects as the system grows.\r\n",
    "slug": "ddd-rich-vs-anemic",
    "link": "/blog/ddd-rich-vs-anemic",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": ["ddd", "architecture", "design", "domain-model"],
    "image": null
  }
]
