[
  {
    "id": 1,
    "title": "Portfolio Overview",
    "description": "Overview of the portfolio repository structure, backend/frontend, and the blog system.",
    "content": "\r\nThis post summarizes the structure and setup of my portfolio repository, including the backend API (`KaiAssistant`), the original Angular frontend, and the new Next.js frontend. It includes notes on architecture, migration, and how the blog system is implemented.\r\n\r\n## Project Overview\r\n\r\n### Backend: KaiAssistant\r\n\r\nThe backend is an ASP.NET Core Web API structured with Domain-Driven Design (DDD). The projects are organized as follows:\r\n\r\n- `KaiAssistant.Domain` — domain entities and models\r\n- `KaiAssistant.Application` — commands, queries, and handlers\r\n- `KaiAssistant.Infrastructure` — persistence, DI, and external integrations\r\n- `KaiAssistant.API` — HTTP endpoints, middleware, and assistant endpoints\r\n\r\n### Frontend Migration: Angular → Next.js\r\n\r\nThe original frontend was Angular-based. I migrated to a `frontent` Next.js + TypeScript project for:\r\n\r\n- Component-first architecture and faster iteration\r\n- Simplified tooling and reduced bundle size\r\n- Improved SSR/SSG support for blog posts\r\n\r\nKey migration points:\r\n\r\n- Routes were mapped from Angular to Next.js pages; dynamic routes like `/blog/[slug]` use static generation.\r\n- Global styles moved to `src/styles`; components use CSS Modules.\r\n- Local markdown posts are read at build time. `blogs.json` now indexes both internal and external posts.\r\n- Carousel and scroll interactions were reimplemented with scroll-snap and pointer events.\r\n\r\n### Frontend (Next.js)\r\n\r\nThe current frontend is component-based, DRY, and uses the blog system reading markdown posts from `src/data/blogs/*.md` combined with `blogs.json` for external entries.\r\n\r\n## Key Features\r\n\r\n- **KaiAssistant API**\r\n\r\n  - Modular DDD structure\r\n  - Health, assistant, and contact endpoints\r\n  - Gemini API integration (requires `GEMINI_API_KEY`)\r\n  - SMTP email support\r\n  - Docker-ready with `docker-compose`\r\n\r\n- **Frontend**\r\n  - Blog index merging local markdown and external posts\r\n  - BlogItem component with CSS Modules\r\n  - Dynamic pages `/blog/[slug]` built statically at compile time\r\n\r\n## Running the Project\r\n\r\n### Backend (KaiAssistant)\r\n\r\nRequirements: .NET 9 SDK, Gemini API key (optional), SMTP credentials (if sending email).\r\n\r\n```bash\r\ncd backend\r\ndotnet restore\r\ndotnet build\r\ndotnet run --project KaiAssistant.API\r\n```\r\n\r\nDocker option:\r\n\r\n```bash\r\ndocker build -t kaiassistant-api .\r\ndocker run -p 5000:5000 \\\r\n  -e GEMINI_API_KEY=your-key \\\r\n  -e SMTP_SENDER_EMAIL=... \\\r\n  kaiassistant-api\r\n```\r\n\r\n### Frontend (Next.js)\r\n\r\n```bash\r\ncd frontend\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\nFor production:\r\n\r\n```bash\r\nnpm run build\r\nnpm start\r\n```\r\n\r\nSite: `http://localhost:3000`.\r\n\r\n## Blog System Notes\r\n\r\n- Local markdown posts in `src/data/blogs/*.md` use frontmatter (title, date, slug).\r\n- `blogs.json` indexes external/internal posts. Local posts override external if slugs match.\r\n- BlogItem links open in a new tab by default.\r\n\r\n## Suggested Improvements\r\n\r\n- Add pagination and date sorting on `/blog`\r\n- Include SEO meta tags and Open Graph data on posts\r\n- Add author profile and tags for better navigation\r\n- Expand tests for blog pages\r\n- Add retry/backoff for Gemini API calls and rate limit handling\r\n\r\n## Summary\r\n\r\nThe repository combines a DDD-based backend with a lean Next.js frontend. Blog posts are easy to add: create a markdown file with frontmatter and rebuild. The setup supports scalable development and clear project organization.\r\n",
    "slug": "portfolio-overview",
    "link": "/blog/portfolio-overview",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": ["portfolio", "kaiassistant", "nextjs", "dotnet", "architecture"],
    "image": null
  },
  {
    "id": 2,
    "title": "BiUrSite: A Web Application for Sharing Ideas and Seeking Advice",
    "description": "BiUrSite — a web app for sharing ideas, with anonymous browsing and verified user interaction.",
    "content": "\r\nIn today's digital world, having a safe and engaging space to share ideas, thoughts, and challenges is more important than ever. **BiUrSite** is a web application I developed to allow users to express themselves, post anonymously or through verified accounts, and receive advice from a supportive community.\r\n\r\n---\r\n\r\n## Core Features\r\n\r\n### Anonymous Users\r\n\r\n- Can browse all posts without registering.\r\n- Limited to viewing only—no interaction allowed.\r\n\r\n### Verified Users\r\n\r\n- Can upload posts and comment on existing posts.\r\n- Report issues, provide feedback, and suggest improvements.\r\n- Must verify email to ensure authenticity.\r\n\r\n### Admin Dashboard\r\n\r\n- View total posts, active users, and reports.\r\n- Ban users based on behavior.\r\n- Publish announcements visible to all users.\r\n\r\n### Additional Features\r\n\r\n- **Email Verification:** Ensures that users are real and active.\r\n- **Ratings & Feedback:** Users can rate posts and provide feedback on advice given.\r\n\r\n---\r\n\r\n## Technical Stack\r\n\r\n**Backend**\r\n\r\n- .NET API (latest version)\r\n- MSSQL Database\r\n- Redis Distributed Cache for performance optimization\r\n- SMTP Email Service\r\n- xUnit for unit testing\r\n- Role-based & policy-based authentication and authorization\r\n\r\n**Frontend**\r\n\r\n- Angular framework\r\n- Initial data via `data.json`\r\n- Admin portal built with Razor pages and API\r\n\r\n**Deployment & DevOps**\r\n\r\n- Docker containerization for backend, frontend, and SQL Server\r\n- Kubernetes orchestration for cloud deployment\r\n- AWS / Azure for production hosting\r\n- Configuration management via `appsettings.json` (backend) and `environment.variable.ts` (frontend)\r\n\r\n---\r\n\r\n## Project Phases\r\n\r\n### Phase 1: Initial Setup\r\n\r\n- Design project structure\r\n- Build working API with OpenAPI documentation\r\n- Version the API for future changes\r\n- Implement basic CRUD operations\r\n- Write unit tests for each module\r\n\r\n### Phase 2: Authentication & Authorization\r\n\r\n- Implement AuthN and AuthZ\r\n- Update unit tests to reflect new authentication logic\r\n\r\n### Phase 3: Security Enhancements\r\n\r\n- Fix potential vulnerabilities: DDOS, XSS, CSRF attacks\r\n\r\n### Phase 4: Frontend Implementation\r\n\r\n- Build frontend pages using static `data.json`\r\n- Implement user interface for posts, comments, and feedback\r\n\r\n### Phase 5: Integration\r\n\r\n- Connect backend API with frontend\r\n- Test API calls and dynamic data handling\r\n\r\n### Phase 6: Deployment\r\n\r\n- Containerize services using Docker\r\n- Deploy using Kubernetes on AWS/Azure\r\n\r\n---\r\n\r\n## Docker Setup\r\n\r\n**Services:**\r\n\r\n- `sql_server_container`: SQL Server container storing application data\r\n- `backend`: .NET API backend\r\n- `frontend`: Angular frontend communicating with backend\r\n\r\n**Run the Application:**\r\n\r\n```bash\r\ndocker-compose up --build\r\n```\r\n",
    "slug": "biursite-project",
    "link": "/blog/biursite-project",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": [
      "Web Development",
      "Full-Stack",
      "Next.js",
      "Angular",
      ".NET",
      "Docker",
      "AWS"
    ],
    "image": null
  },
  {
    "id": 3,
    "title": "The C#/.NET Revolution: Improvements Across Versions",
    "description": "A concise overview of major C# and .NET improvements across versions.",
    "content": "\r\nC# and the .NET ecosystem have evolved tremendously since their inception. Each version of the language and framework has brought new features, performance improvements, and productivity boosts for developers. Here’s a chronological look **from the latest version down to the earliest**, highlighting the most significant changes.\r\n\r\n---\r\n\r\n## C# 13 and .NET 9\r\n\r\n- **Released:** November 2024\r\n- **Key Features:**\r\n  - `params` collections for more flexible argument handling.\r\n  - New `System.Threading.Lock` type for improved thread synchronization.\r\n  - Implicit “from the end” (`^`) index operator in object initializers.\r\n  - Ref/unsafe support in iterators/async methods, partial properties/indexers.\r\n- **.NET 9 Enhancements:**\r\n  - Runtime improvements: adaptive GC heap, ARM64 vectorization, faster startup.\r\n  - Library enhancements: `System.Text.Json` schema export, LINQ `CountBy`/`AggregateBy`, improved priority queues.\r\n  - Cloud/AI tooling: unified AI layer, tensor support, improved SDK tooling.\r\n- **Impact:** High-performance, cloud-native readiness, and AI/ML support; STS (short-term support) release.\r\n\r\n---\r\n\r\n## C# 12 and .NET 8\r\n\r\n- **Expected:** 2025\r\n- **Key Features:**\r\n  - Primary constructors for structs.\r\n  - Default lambda expressions for delegates.\r\n  - Collection expressions and improved interpolated strings.\r\n- **Impact:** Further reduces boilerplate, improves readability, and boosts performance.\r\n\r\n---\r\n\r\n## C# 11 and .NET 7\r\n\r\n- **Released:** 2022\r\n- **Key Features:**\r\n  - Raw string literals.\r\n  - List patterns.\r\n  - Required members.\r\n  - Generic math support, UTF-8 string literals.\r\n- **Impact:** Simplifies multi-line strings, strengthens pattern matching, enhances generic math support.\r\n\r\n---\r\n\r\n## C# 10 and .NET 6\r\n\r\n- **Released:** 2021\r\n- **Key Features:**\r\n  - Global using directives.\r\n  - File-scoped namespaces.\r\n  - Record structs.\r\n  - Improved pattern matching, interpolated string handlers.\r\n- **Impact:** Reduced boilerplate, improved compile-time safety, long-term support (LTS).\r\n\r\n---\r\n\r\n## C# 9 and .NET 5\r\n\r\n- **Released:** 2020\r\n- **Key Features:**\r\n  - Records and init-only setters.\r\n  - Top-level statements.\r\n  - Pattern matching enhancements, covariant returns.\r\n- **Impact:** Simplifies immutable data modeling and small programs; unified .NET platform.\r\n\r\n---\r\n\r\n## C# 8 and .NET Core 3\r\n\r\n- **Released:** 2019\r\n- **Key Features:**\r\n  - Nullable reference types.\r\n  - Asynchronous streams.\r\n  - Ranges and indices, default interface methods.\r\n- **Impact:** Improves safety, simplifies large data streaming, and allows better API evolution.\r\n\r\n---\r\n\r\n## C# 7.x and .NET Core 1+\r\n\r\n- **Released:** 2016–2017\r\n- **Key Features:**\r\n  - Tuples, pattern matching.\r\n  - Local functions, out variables, ref returns.\r\n- **Impact:** More expressive code and cross-platform capabilities with .NET Core.\r\n\r\n---\r\n\r\n## C# 6 and .NET Framework 4.6\r\n\r\n- **Released:** 2015\r\n- **Key Features:**\r\n  - Expression-bodied members.\r\n  - String interpolation.\r\n  - Null-conditional operators (`?.`), `nameof`.\r\n- **Impact:** Cleaner, safer, more readable code.\r\n\r\n---\r\n\r\n## C# 5 and .NET Framework 4.5\r\n\r\n- **Released:** 2012\r\n- **Key Features:**\r\n  - Async and await keywords.\r\n  - Caller Info attributes.\r\n- **Impact:** Simplifies asynchronous programming, improving maintainability and I/O performance.\r\n\r\n---\r\n\r\n## C# 4 and .NET Framework 4.0\r\n\r\n- **Released:** 2010\r\n- **Key Features:**\r\n  - Dynamic binding (`dynamic`).\r\n  - Optional parameters, named arguments.\r\n  - Improved COM interoperability.\r\n- **Impact:** Simplifies interop with dynamic languages and COM objects; cleaner APIs.\r\n\r\n---\r\n\r\n## C# 3 and .NET Framework 3.5\r\n\r\n- **Released:** 2007\r\n- **Key Features:**\r\n  - LINQ, lambda expressions.\r\n  - Extension methods, object and collection initializers.\r\n- **Impact:** Revolutionized querying and in-memory data manipulation; functional programming style support.\r\n\r\n---\r\n\r\n## C# 2 and .NET Framework 2.0\r\n\r\n- **Released:** 2005\r\n- **Key Features:**\r\n  - Generics, nullable types.\r\n  - Iterators (`yield`), partial classes, anonymous methods.\r\n- **Impact:** Type-safe collections, simplified iteration, and database value handling.\r\n\r\n---\r\n\r\n## C# 1 and .NET Framework 1.0\r\n\r\n- **Released:** 2002\r\n- **Key Features:**\r\n  - Classes, interfaces, delegates, properties, exception handling.\r\n- **Impact:** Laid the foundation for object-oriented programming in C# and introduced the managed runtime.\r\n\r\n---\r\n\r\n## The Big Picture\r\n\r\nFrom its beginnings in 2002 to the latest C# 13/.NET 9 release, C# and .NET have evolved into a high-performance, cross-platform ecosystem. Microsoft has consistently focused on:\r\n\r\n- **Performance:** Runtime and JIT improvements.\r\n- **Productivity:** Reduced boilerplate, modern syntax.\r\n- **Safety:** Null safety, type safety, immutability.\r\n- **Cross-platform:** From Windows-only to Linux, macOS, and mobile apps.\r\n\r\nC# and .NET remain powerful tools for modern software development, proving that thoughtful evolution can keep a language and framework relevant for decades.\r\n\r\n---\r\n\r\n> _“C# has evolved from a simple object-oriented language into a versatile platform for building modern, high-performance applications. Every version brings both incremental and groundbreaking improvements, shaping how developers write software today.”_\r\n",
    "slug": "csharp-dotnet-evolution",
    "link": "/blog/csharp-dotnet-evolution",
    "date": "2025-11-11",
    "tags": [],
    "image": null
  },
  {
    "id": 4,
    "title": "Job Tracker Web Application: A Modern .NET Microservices Project",
    "description": "Job Tracker — a .NET microservices example demonstrating DDD and CQRS.",
    "content": "\r\nThe **Job Tracker Web Application** is designed to help users manage job listings, applications, and status updates. This project was developed solo to explore microservices, Domain-Driven Design (DDD), CQRS (Command Query Responsibility Segregation), and the full software development lifecycle. It leverages modern .NET best practices for scalability, clean code, and maintainability.\r\n\r\n---\r\n\r\n## Key Features\r\n\r\n- **Job Listings Management:** Create, read, update, and delete job postings.\r\n- **Job Applications:** Users can apply for jobs and track their application status.\r\n- **CQRS:** Commands (write operations) and queries (read operations) are clearly separated for improved scalability.\r\n- **Email Notifications:** Automated emails notify users when job statuses change.\r\n- **Microservices Architecture:** The application is modularized into microservices to enhance maintainability and scalability.\r\n- **Clean Code & DDD:** Implements Domain-Driven Design principles for a maintainable and scalable architecture.\r\n\r\n---\r\n\r\n## Tech Stack\r\n\r\n- **Backend:** .NET 6+ (C#)\r\n- **Architecture:** Microservices, CQRS, Domain-Driven Design\r\n- **Frameworks & Tools:**\r\n  - MediatR: CQRS command and query handling\r\n  - SendGrid / SMTP: Email notifications\r\n  - Serilog: Structured logging\r\n  - Moq / NUnit: Unit testing\r\n  - Docker (optional): Containerization\r\n  - CI/CD: GitHub Actions or GitLab CI pipelines\r\n  - EF Core: Database ORM\r\n\r\n---\r\n\r\n## Setup\r\n\r\n### Prerequisites\r\n\r\nBefore running the application, ensure you have:\r\n\r\n- **.NET 6+ SDK** installed ([Download .NET](https://dotnet.microsoft.com/download))\r\n- **Docker** (optional, for containerization)\r\n- **SMTP/SendGrid account** for email notifications\r\n\r\n---\r\n\r\n### Installation Steps\r\n\r\n1. **Clone the Repository**\r\n\r\n```bash\r\ngit clone git@github.com:Kheang1409/job-tracker-api.git\r\ncd job-tracker-api\r\n```\r\n\r\n2. **Install Dependencies**\r\n\r\n```bash\r\ndotnet restore\r\n```\r\n\r\n3. **Configure Environment Variables**\r\n\r\n- Set up `.env` or `appsettings.json` with email credentials and database connection strings.\r\n\r\n4. **Run the Application**\r\n\r\n```bash\r\ndotnet run --project JobTracker.Api\r\n```\r\n\r\n5. **Optional: Run with Docker**\r\n\r\n```bash\r\ndocker-compose up --build\r\n```\r\n\r\n---\r\n\r\n## What I Learned\r\n\r\nBuilding this project taught me a wide range of technical and architectural skills:\r\n\r\n- **Domain-Driven Design (DDD):** Learned how to model complex business domains using aggregates, entities, and value objects.\r\n- **CQRS Implementation:** Understood the benefits of separating write operations (commands) from read operations (queries) to improve scalability and maintainability.\r\n- **Microservices Architecture:** Gained practical experience decomposing a monolithic application into loosely coupled services.\r\n- **Asynchronous Email Handling:** Integrated SendGrid/SMTP for real-time email notifications using background services.\r\n- **Unit Testing & Mocks:** Learned to write effective tests for CQRS commands, queries, and services using Moq and NUnit.\r\n- **Logging & Observability:** Implemented structured logging with Serilog for better monitoring and debugging.\r\n- **Containerization & CI/CD:** Practiced containerizing the services with Docker and setting up continuous integration pipelines with GitHub Actions or GitLab CI.\r\n- **Clean Code & Maintainability:** Applied SOLID principles and DDD to produce modular, maintainable, and testable code.\r\n\r\n---\r\n\r\nThis project demonstrates modern .NET architecture principles while providing a functional job tracking platform. It serves as a practical example of scalable, maintainable, and testable enterprise-grade application design.\r\n\r\n---\r\n\r\nIf you want, I can **also add a “Next Steps / Future Enhancements” section linked to the lessons learned**, so it not only shows what you learned but also what you plan to do next, making it more engaging for readers and potential employers. Do you want me to do that?\r\n\r\n```\r\n\r\n```\r\n",
    "slug": "job-tracker-web-application",
    "link": "/blog/job-tracker-web-application",
    "date": "2025-11-11",
    "tags": [],
    "image": null
  },
  {
    "id": 5,
    "title": "DDD: Rich Domain Model vs Anemic Domain Model",
    "description": "Brief comparison of Rich and Anemic domain models, with guidance for choosing between them.",
    "content": "\r\n> Short summary: Rich domain models encapsulate behavior and data together (the object is responsible for its invariants). Anemic models keep data and behavior separate (DTOs/entities are data-only). Each approach has trade-offs — this post explains both, shows examples, and gives guidance for choosing or migrating.\r\n\r\n## What is an Anemic Domain Model?\r\n\r\nAn Anemic Domain Model keeps entities as data containers (properties only). Business logic and rules live in separate services or application layers. This can be simple and straightforward, but risks scattering rules across services and losing encapsulation.\r\n\r\nPros:\r\n\r\n- Simple DTO-like entities\r\n- Easy to serialize/deserialize and map to persistence\r\n- Familiar to teams coming from CRUD/service-oriented patterns\r\n\r\nCons:\r\n\r\n- Business rules are often duplicated or scattered\r\n- Harder to guarantee object invariants\r\n- Tests can become larger (need to set up data and call services)\r\n\r\nExample (C# - anemic):\r\n\r\n```csharp\r\npublic class Order {\r\n  public Guid Id { get; set; }\r\n  public List<OrderLine> Lines { get; set; }\r\n  public decimal Total { get; set; }\r\n}\r\n\r\npublic class OrderService {\r\n  public void AddItem(Order order, Product p, int qty) {\r\n    // service mutates Order and updates Total\r\n  }\r\n}\r\n```\r\n\r\n## What is a Rich (Behaviorful) Domain Model?\r\n\r\nA Rich Domain Model puts behavior inside the domain objects. Entities enforce their own invariants and provide meaningful methods to operate on them. This matches the core DDD idea: the domain model expresses the domain language and protects its invariants.\r\n\r\nPros:\r\n\r\n- Encapsulation: invariants are enforced in one place\r\n- Clear, intention-revealing APIs (Order.AddItem())\r\n- Easier to reason about correctness and test behavior directly\r\n\r\nCons:\r\n\r\n- Slightly more design effort initially\r\n- Need clear boundaries to avoid anemic services hiding inside objects\r\n\r\nExample (C# - rich):\r\n\r\n```csharp\r\npublic class Order {\r\n  private readonly List<OrderLine> _lines = new();\r\n  public IReadOnlyCollection<OrderLine> Lines => _lines.AsReadOnly();\r\n\r\n  public void AddItem(Product p, int qty) {\r\n    if (qty <= 0) throw new ArgumentException(\"qty\");\r\n    var existing = _lines.FirstOrDefault(l => l.ProductId == p.Id);\r\n    if (existing != null) existing.Increase(qty);\r\n    else _lines.Add(new OrderLine(p.Id, p.Price, qty));\r\n  }\r\n\r\n  public decimal Total => _lines.Sum(l => l.Subtotal);\r\n}\r\n```\r\n\r\nHere `Order` manages its lines and computes the total — callers can't put the `Order` into an invalid state without calling its API.\r\n\r\n## Choosing between them\r\n\r\n- Start with the domain complexity: If your domain has non-trivial rules and invariants, prefer a rich model.\r\n- If your application is primarily CRUD with thin business logic, an anemic model with services can be pragmatic.\r\n- Teams moving to DDD often start with anemic models and gradually introduce rich behaviors where it matters.\r\n\r\n## Migration tips (Anemic → Rich)\r\n\r\n1. Identify invariants & business rules currently enforced in services or spread across code.\r\n2. Introduce small, focused domain methods that encapsulate those rules (e.g., `Order.AddItem`, `Customer.CanPlaceOrder`).\r\n3. Keep persistence mapping straightforward: repositories still persist entities, but call domain methods instead of manipulating properties directly.\r\n4. Add tests around domain behaviors (unit tests on the domain object) before removing service-level logic.\r\n\r\n## Small JS/TS example (Rich model flavor)\r\n\r\n```ts\r\nclass Order {\r\n  private lines: OrderLine[] = [];\r\n\r\n  addItem(product: Product, qty: number) {\r\n    if (qty <= 0) throw new Error(\"qty must be > 0\");\r\n    const item = this.lines.find((l) => l.productId === product.id);\r\n    if (item) item.qty += qty;\r\n    else this.lines.push({ productId: product.id, price: product.price, qty });\r\n  }\r\n\r\n  total() {\r\n    return this.lines.reduce((s, l) => s + l.price * l.qty, 0);\r\n  }\r\n}\r\n```\r\n\r\n## When to avoid a rich model\r\n\r\n- Extremely simple CRUD apps where all business logic is in stored procedures or in a gateway layer.\r\n- When team familiarity and delivery speed require minimal upfront design — but add targeted rich models where bugs or duplication appear.\r\n\r\n## Summary\r\n\r\nBoth patterns are valid. Prefer a rich, behaviorful domain model when domain rules, invariants, and maintainability matter. Use anemic models pragmatically for simple data-centric applications, but remain ready to extract domain behaviors into objects as the system grows.\r\n",
    "slug": "ddd-rich-vs-anemic",
    "link": "/blog/ddd-rich-vs-anemic",
    "date": "2025-11-11",
    "author": "Kai",
    "tags": ["ddd", "architecture", "design", "domain-model"],
    "image": null
  }
]
